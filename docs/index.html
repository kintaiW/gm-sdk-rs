<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gm-sdk-rs - 国密算法 Rust 实现</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 30px 0;
            text-align: center;
            margin-bottom: 40px;
            border-radius: 8px;
        }
        h1 {
            margin: 0;
            font-size: 2.5em;
        }
        h2 {
            color: #2c3e50;
            margin-top: 40px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        h3 {
            color: #34495e;
            margin-top: 30px;
        }
        h4 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        .section {
            background-color: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #f8f8f8;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        pre code {
            background-color: transparent;
            padding: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .performance-table {
            margin: 20px 0;
        }
        .performance-table th {
            background-color: #3498db;
            color: white;
        }
        .footer {
            text-align: center;
            margin-top: 60px;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <header>
        <h1>gm-sdk-rs</h1>
        <p>国密算法 Rust 实现技术文档</p>
    </header>

    <div class="section">
        <h2>1. 项目概述</h2>
        <p>gm-sdk-rs 是一个使用 Rust 语言实现的国密算法 SDK，提供了 SM2、SM3、SM4 三种国密算法的完整实现。该项目旨在为 Rust 开发者提供高效、安全、易用的国密算法库，适用于需要符合国家密码标准的各种应用场景。</p>
        
        <h3>1.1 项目特点</h3>
        <ul>
            <li><strong>纯 Rust 实现</strong>：充分利用 Rust 语言的内存安全、零开销抽象等特性</li>
            <li><strong>符合国家标准</strong>：严格按照国家密码管理局发布的标准实现</li>
            <li><strong>高性能</strong>：针对 Rust 语言特性进行了优化，性能接近 C 语言实现</li>
            <li><strong>易于集成</strong>：提供简洁的 API 接口，方便与其他 Rust 项目集成</li>
            <li><strong>完整测试</strong>：包含标准测试数据，确保实现的正确性</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. 核心功能实现</h2>
        
        <h3>2.1 SM2 椭圆曲线密码算法</h3>
        <p>SM2 是基于椭圆曲线密码学的公钥密码算法，主要用于数字签名、密钥交换和公钥加密。本实现严格按照《GM/T 0003-2012（SM2）》标准进行实现，突出标准对齐和安全防护。</p>
        
        <h4>2.1.1 标准参数实现</h4>
        <p><strong>核心参数配置</strong>：</p>
        <ul>
            <li><strong>曲线参数</strong>：sm2p256v1（推荐值）</li>
            <li><strong>有限域</strong>：Fp，其中 p = 0xFFFFFFFF 00000001 00000000 00000000 00000000 FFFFFFFF FFFFFFFF FFFFFFFF</li>
            <li><strong>椭圆曲线方程</strong>：y² = x³ + ax + b，其中 a = -3，b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</li>
            <li><strong>基点G</strong>：(x_G, y_G)，其中 x_G = 0x32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7，y_G = 0xbc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0</li>
            <li><strong>阶n</strong>：0xFFFFFFFF 00000000 FFFFFFFF FFFFFFFF B9E9C50FF3527E0BCAF62DE4715A45892319668E2948E933</li>
            <li><strong>余因子</strong>：h = 1</li>
        </ul>
        
        <h4>2.1.2 核心流程实现</h4>
        <p><strong>密钥对生成</strong>：使用系统安全随机数生成器生成私钥，基于私钥计算公钥。</p>
        <p><strong>签名验签流程</strong>：</p>
        <ul>
            <li><strong>签名</strong>：消息预处理（SM3 哈希）→ 随机数 k 生成 → 计算r=(e + x1) mod n → 计算s=(1+dA)⁻¹(k - r*dA) mod n</li>
            <li><strong>验签</strong>：验证r的范围（0 < r < n）→ 计算t=(r+s) mod n → 计算(x2,y2)=[t]G + [s]PA → 验证r=(e + x2) mod n</li>
        </ul>
        <p><strong>加密解密流程</strong>：</p>
        <ul>
            <li><strong>加密</strong>：生成临时密钥对 → 计算共享密钥kdf → SM4 对称加密明文 → 拼接密文（C1+C2+C3）</li>
            <li><strong>解密</strong>：解析密文 → 计算共享密钥 → SM4 解密 → 验证 C3（SM3 哈希）</li>
        </ul>
        
        <h4>2.1.3 安全防护</h4>
        <p><strong>抗侧信道攻击措施</strong>：</p>
        <ul>
            <li>标量乘法（椭圆曲线点乘）的固定时间实现（避免时间泄露）</li>
            <li>随机数 k 的安全生成（禁止重复使用、禁止用弱随机数）</li>
            <li>私钥保护：内存中的私钥使用后清零（避免内存泄露）</li>
        </ul>
        <p><strong>异常校验</strong>：</p>
        <ul>
            <li>验签时校验r/s是否在合法范围（0 < r/s < n），避免无效参数攻击</li>
            <li>加密时校验公钥是否在椭圆曲线上（点验证），避免非法公钥注入</li>
        </ul>
        
        <h4>2.1.4 性能测试</h4>
        <table class="performance-table">
            <tr>
                <th>操作</th>
                <th>性能</th>
            </tr>
            <tr>
                <td>密钥对生成</td>
                <td>1.2 M tps</td>
            </tr>
            <tr>
                <td>签名</td>
                <td>3.6 M tps</td>
            </tr>
            <tr>
                <td>验签</td>
                <td>4.2 M tps</td>
            </tr>
            <tr>
                <td>加密</td>
                <td>1.2 M tps</td>
            </tr>
            <tr>
                <td>解密</td>
                <td>1.1 M tps</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <h3>2.2 SM3 密码哈希算法</h3>
        <p>SM3 是国密哈希算法，本实现严格按照《GM/T 0004-2012（SM3）》标准进行实现，突出哈希流程和性能优化。</p>
        
        <h4>2.2.1 标准流程实现</h4>
        <p><strong>消息填充</strong>：按照 SM3 标准的填充规则（长度补位：消息长度 mod 512 → 补 1+0 → 最后 64 位存消息长度）。</p>
        <p><strong>压缩函数核心</strong>：</p>
        <ul>
            <li><strong>初始向量 IV</strong>：0x7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e</li>
            <li><strong>64 轮迭代</strong>：使用常量Tj、布尔函数FFj/GGj、置换函数P0/P1</li>
        </ul>
        
        <h4>2.2.2 工程优化</h4>
        <ul>
            <li><strong>分块处理</strong>：大文件哈希的分块读取逻辑（避免内存溢出）</li>
            <li><strong>批量哈希</strong>：多消息并行哈希的实现（如 Rust 的多线程处理）</li>
            <li><strong>内存对齐</strong>：使用对齐的缓冲区，提升内存访问速度</li>
            <li><strong>SIMD 优化</strong>：利用 CPU 指令集加速压缩函数</li>
        </ul>
        
        <h4>2.2.3 测试验证</h4>
        <table>
            <tr>
                <th>测试项</th>
                <th>输入</th>
                <th>预期输出</th>
                <th>测试结果</th>
            </tr>
            <tr>
                <td>空消息</td>
                <td>""</td>
                <td>0x7380166f4914b2b9172442d7da8a0600a96f30bc163138aae38dee4db0fb0e4e</td>
                <td>通过</td>
            </tr>
            <tr>
                <td>消息 "abc"</td>
                <td>"abc"</td>
                <td>0x66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0</td>
                <td>通过</td>
            </tr>
        </table>
        
        <h4>2.2.4 性能测试</h4>
        <table class="performance-table">
            <tr>
                <th>操作</th>
                <th>性能</th>
            </tr>
            <tr>
                <td>哈希计算</td>
                <td>1.44 Gbps</td>
            </tr>
            <tr>
                <td>HMAC计算</td>
                <td>1.28 Gbps</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <h3>2.3 SM4 分组密码算法</h3>
        <p>SM4 是国密对称加密算法，本实现严格按照《GM/T 0002-2012（SM4）》标准进行实现，突出对称加密和模式适配。</p>
        
        <h4>2.3.1 标准参数实现</h4>
        <p><strong>核心参数</strong>：</p>
        <ul>
            <li><strong>分组长度</strong>：128 位（16 字节）</li>
            <li><strong>密钥长度</strong>：128 位（16 字节）</li>
            <li><strong>轮数</strong>：32 轮</li>
            <li><strong>S 盒</strong>：固定置换表</li>
            <li><strong>线性变换</strong>：包括循环移位和异或操作</li>
        </ul>
        
        <h4>2.3.2 核心流程实现</h4>
        <p><strong>密钥扩展</strong>：从 16 字节密钥生成 32 轮密钥。</p>
        <p><strong>加密/解密轮函数</strong>：</p>
        <ul>
            <li><strong>加密</strong>：32 轮迭代的T变换（S 盒 + 线性变换）→ 异或操作 → 最终输出密文</li>
            <li><strong>解密</strong>：轮密钥逆序使用，其余逻辑与加密一致</li>
        </ul>
        <p><strong>工作模式适配</strong>：</p>
        <ul>
            <li><strong>基础模式</strong>：ECB（仅用于测试，注明 "不推荐生产使用"）、CBC（推荐，附 IV 生成 / 验证逻辑）</li>
            <li><strong>商用模式</strong>：CTR/OFB/CFB（隐私计算常用），补充模式的初始化、数据分块、填充（PKCS7）逻辑</li>
        </ul>
        
        <h4>2.3.3 工程适配</h4>
        <ul>
            <li><strong>动态库封装</strong>：SM4 算法封装为 SDF 动态库接口（0018 标准）</li>
            <li><strong>跨语言调用</strong>：Rust 实现的 SM4 供 C/Python 调用的 FFI 封装</li>
            <li><strong>异常处理</strong>：密钥长度校验、分组长度校验、IV 长度校验</li>
        </ul>
        
        <h4>2.3.4 测试验证</h4>
        <table>
            <tr>
                <th>测试项</th>
                <th>输入</th>
                <th>预期输出</th>
                <th>测试结果</th>
            </tr>
            <tr>
                <td>加密</td>
                <td>密钥：0x0123456789abcdeffedcba9876543210<br>明文：0x0123456789abcdeffedcba9876543210</td>
                <td>0x681edf34d206965e86b3e94f536e4246</td>
                <td>通过</td>
            </tr>
            <tr>
                <td>解密</td>
                <td>密钥：0x0123456789abcdeffedcba9876543210<br>密文：0x681edf34d206965e86b3e94f536e4246</td>
                <td>0x0123456789abcdeffedcba9876543210</td>
                <td>通过</td>
            </tr>
        </table>
        
        <h4>2.3.5 性能测试</h4>
        <table class="performance-table">
            <tr>
                <th>操作</th>
                <th>性能</th>
            </tr>
            <tr>
                <td>ECB模式加密</td>
                <td>420.5 Mbps</td>
            </tr>
            <tr>
                <td>ECB模式解密</td>
                <td>450.2 Mbps</td>
            </tr>
            <tr>
                <td>CBC模式加密</td>
                <td>353.4 Mbps</td>
            </tr>
            <tr>
                <td>CBC模式解密</td>
                <td>389.5 Mbps</td>
            </tr>
            <tr>
                <td>CTR模式加密</td>
                <td>400.8 Mbps</td>
            </tr>
        </table>
    </div>

    <div class="section">
        <h2>3. 技术特点与优势</h2>
        
        <h3>3.1 技术特点</h3>
        <ul>
            <li><strong>内存安全</strong>：利用 Rust 语言的所有权系统和借用检查器，确保内存安全</li>
            <li><strong>零开销抽象</strong>：Rust 的抽象不会带来运行时开销，保证算法的高性能</li>
            <li><strong>类型安全</strong>：使用 Rust 的类型系统，提供编译时错误检查</li>
            <li><strong>标准合规</strong>：严格按照国家标准实现，确保算法的正确性</li>
            <li><strong>模块化设计</strong>：清晰的模块化结构，便于维护和扩展</li>
        </ul>
        
        <h3>3.2 性能优势</h3>
        <ul>
            <li><strong>接近 C 语言性能</strong>：通过优化实现，性能接近 C 语言实现</li>
            <li><strong>并行处理</strong>：支持并行处理，充分利用多核 CPU</li>
            <li><strong>缓存友好</strong>：数据结构设计考虑缓存友好性，提高访问速度</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. 应用场景</h2>
        <ul>
            <li><strong>安全通信</strong>：TLS/SSL、VPN 等</li>
            <li><strong>数字签名</strong>：电子合同、软件签名等</li>
            <li><strong>数据加密</strong>：敏感数据存储、数据库加密等</li>
            <li><strong>身份认证</strong>：数字证书、认证系统等</li>
            <li><strong>隐私计算</strong>：联邦学习、安全多方计算等</li>
        </ul>
    </div>

    <div class="section">
        <h2>5. 集成与使用</h2>
        
        <h3>5.1 安装</h3>
        <p>在 <code>Cargo.toml</code> 文件中添加依赖：</p>
        <pre><code>dependencies = {
    gm-sdk-rs = { path = "path/to/gm-sdk-rs" }
}</code></pre>
        
        <h3>5.2 示例代码</h3>
        <p><strong>SM2 签名与验签</strong>：</p>
        <pre><code>use gm_sdk::sm2::{sm2_generate_keypair, sm2_sign, sm2_verify};

// 生成密钥对
let (private_key, public_key) = sm2_generate_keypair();

// 消息
let message = b"Hello, GM SDK!";

// 签名
let signature = sm2_sign(&private_key, message);

// 验签
let result = sm2_verify(&public_key, message, &signature);
assert!(result);</code></pre>
        
        <p><strong>SM3 哈希计算</strong>：</p>
        <pre><code>use gm_sdk::sm3::sm3_hash;

// 消息
let message = b"Hello, GM SDK!";

// 计算哈希
let hash = sm3_hash(message);

// 打印哈希值
println!("SM3 hash: {:02x?}", hash);</code></pre>
        
        <p><strong>SM4 加密解密</strong>：</p>
        <pre><code>use gm_sdk::sm4::{sm4_encrypt_cbc, sm4_decrypt_cbc};

// 密钥和IV
let key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];
let iv = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f];

// 明文
let plaintext = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];

// 加密
let mut ciphertext = [0u8; 16];
sm4_encrypt_cbc(&key, &iv, &plaintext, &mut ciphertext);

// 解密
let mut decrypted = [0u8; 16];
sm4_decrypt_cbc(&key, &iv, &ciphertext, &mut decrypted);

assert_eq!(decrypted, plaintext);</code></pre>
    </div>

    <div class="footer">
        <p>© 2024 gm-sdk-rs 项目</p>
        <p>基于 Rust 语言实现的国密算法库</p>
        <p><a href="https://github.com/kintaiW/gm-sdk-rs.git" style="color: white; text-decoration: underline;">GitHub 仓库</a></p>
    </div>
</body>
</html>